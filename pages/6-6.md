# 不要自己來

主要挑戰
- 複雜性高：需處理非同步資料提取、程式碼拆分、React 生命週期事件
- 安全風險：容易產生資料洩漏問題
- 開發成本：耗時且容易出錯

具體安全問題
- 共享快取漏洞：單一變數儲存所有用戶資料
- 資料洩漏風險：用戶 A 的敏感資料可能被用戶 B 取得

推薦解決方案
- 使用成熟框架：Next.js、Remix、Gatsby
- 內建安全機制：框架提供資料隔離功能
- 社群驗證：經過大型開發社群測試與驗證

---
hideInToc: true
layout: two-cols
layoutClass: gap-16
---

```javascript
// server.js

// 匯入 express 模組
const express = require("express");

// 建立新的 express 應用程式實例
const app = express();

// 宣告一個變數來保存快取的使用者資料
// 最初，它是 null，因為還沒有資料被快取
let cachedUserData = null;
```

::right::

```javascript
// 為路徑 "/user/:userId" 的 GET 請求定義一個處理器
// 這會使用指定的使用者資料來回應
app.get("/user/:userId", (req, res) => {
  // 從請求參數提取 userId
  const { userId } = req.params;
  
  // 檢查是否有被快取的使用者資料
  // 如果有，使用被快取的資料來回應
  if (cachedUserData) {
    return res.json(cachedUserData);
  }
// 如果沒有，從資料庫或其他地方定義處取使用者資料
// 假設 fetchUserData 函式在其他地方定義
  const userData = fetchUserData(userId);
  
  // 使用所提取的使用者資料來更新快取
  cachedUserData = userData;
  
  // 使用所提取的使用者資料來回應
  res.json(userData);
});

// 啟動伺服器，監聽連接埠 3000
// 當伺服器成功啟動時，將訊息記錄到主控台
app.listen(3000, () => {
  console.log("Server listening on port 3000");
});
```

---
hideInToc: true
zoom: 0.8
---

**主要問題**
- **快取安全漏洞**：程式碼中的 `cachedUserData` 變數被所有請求共享，導致不同用戶可能收到其他人的敏感資料

**具體風險場景**
- 用戶端 A 請求 `/user/1` → 資料被快取
- 用戶端 B 請求 `/user/2` → 收到用戶端 A 的資料
- **結果**：嚴重的資料洩漏安全問題

**改善建議**
- 使用物件結構快取，以 `userId` 作為鍵值
- 確保每個使用者都有獨立的快取空間

**核心觀點**
- **避免自造輪子**：自行開發伺服器端算繪容易產生人為錯誤
- **使用成熟框架**：Next.js、Remix、Gatsby 等框架已針對安全問題提供完善解決方案
- **安全優先**：這些框架採用隔離的資料提取方法，有效防止資料洩漏

<br/>

> ### 依賴經過大型社群驗證的框架，比自行開發更安全且有效率。
