# 於 React 中的伺服器渲染 API

<br />

我們在 Express 中透過 Server Side Render 的方式建立 React App。

其中最主要的是我們使用了 `ReactDOMServer.renderToString()`，將 React APP 渲染成 HTML 字串。

接下來會討論幾個 React 提供的 SSR API，包含用法、優點、缺點以及何時適合將其運用：

- `renderToString()`
- `renderToPipableStream()`
- `renderToReadableStream()`

---
hideInToc: true
---

# renderToString

將 react 組件渲染成完整的 html 字串

優點: 因為 api 是同步的，因此可以回傳一個完整的 HTML 字串，有助於提升效能、SEO和便利性。

用法: 從 `react-dom/server` 套件匯入 `renderToString()`

```jsx
import React from "react"
import { renderToString } from "react-dom/server"

function App(){
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>This is a simple React app.</p>
    </div>
  )
}

const html = renderToString(<App/>)
console.log(html)
```

---
hideInToc: true
---


## 它是如何運作的

`renderToString()` 會遍歷 react 元素 tree，輸出字串來轉換成真實 DOM 元素


```jsx
// React JSX
React.createElement("div", {}, 'hello world!')

// output
{ 
  type: "div", 
  props: {},
  children: ['hello world!'] 
}

// next for renderToString API
// ...
```


### JSX 轉換成 HTML 的流程

`JSX` -> `React.createElement` -> `React element` -> `renderToString(React element)` -> `HTML` 

`renderToString()` 的輸出讓我們更容易理解 React 如何用宣告式語法構建出實際的 DOM 樹狀結構。

---
hideInToc: true
---

### 問題：如果一次大量要處理複雜的 react element tree?

```jsx
React.createElement( 
  "section",
  { id: "list" }, 
  React.createElement("h1", {}, "This is my list!"),
  React.createElement("p", {}, "Isn't my list amazing? It contains amazing things!"),
  React.createElement("ul", {}, 
    amazingThings.map((t) => React.createElement("li", { key: t.id }, t.label))
  )
);
```
     
轉換成這段程式： 

```html
<section id="list"> 
  <h1>This is my list!</h1> 
  <p>Isn't my list amazing? It contains amazing things!</p> 
  <ul> 
    <li>Thing 1</li> 
    <li>Thing 2</li> 
    <li>Thing 3</li>
  </ul>
</section>
```

---
hideInToc: true
---

### 缺點

`renderToString()` 採用同步運行，必須先生成整個 HTML 字串才能回傳。

這會帶來幾個問題:
- 效能瓶頸：大型應用在生成整頁內容時，可能造成事件迴圈被阻塞、記憶體暴增，導致伺服器回應變慢或崩潰。
- 無法串流：因為必須等整個 HTML 完成後才能輸出，會造成較長的 TTFB（Time To First Byte），使用者需更久才能看到畫面。

為了改善這些限制，React 提供了可串流輸出的替代 API，如:
- `renderToPipeableStream`（Node.js）
- `renderToReadableStream`（瀏覽器）

目標：**能邊生成邊傳送 HTML，提升效能與回應速度** 。

---
hideInToc: true
---

# renderToPipeableStream
1. 適用於大型的 React App 渲染至 node.js
2. 完全支援 React 並行功能（包括 Suspense），可以在伺服器炫渲染期間更妥善的處理非同步資料提取。
3. 以非同步和累加的方式將 HTML 區塊送到用戶端，帶來更快的 TTFB 值。

<br/>

### 寫法參考：[Github](https://github.com/Yo0GuitarIT/react-ssr-demo)
切換 branch: `renderToPipeableStream`


<div style="width: 100%; display: flex; justify-content: end; margin-top: -80px">
  <img 
    src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*il9OcmDsPM3v5JP05fpYFA.png" 
    alt="" 
    style="width: auto; height: 280px;"/>
</div>

---
hideInToc: true
---

# 運作方式
1. 接收 React element 轉換成 node.js 串流（~~HTML字串~~） 
2. 以區塊（chunk）方式處理處理資料，使用於大型 React App

<br />
<div class="flex justify-center">
  <img border="rounded" src="https://cover.sli.dev" alt="" style="max-width: 600px; width: 80%;">
</div>


---
hideInToc: true
---

# Node.js 串流的四種類型
介於來源和目的之間的資料流，可以視為傳遞資料的管道

1. **可讀串流（Readable Stream）**

   * 代表資料來源，可被讀取。
   * 會觸發事件：`data`、`end`、`error`。
   * 範例：讀檔案、接收 HTTP 請求、產生器產生資料。
   * React 的 `renderToPipeableStream()` 回傳的就是可讀串流，可將 HTML 輸出到可寫串流（如 `res`）。

2. **可寫串流（Writable Stream）**

   * 代表資料的目的地，可被寫入。
   * 主要方法：`write()`、`end()`。
   * 事件：`drain`（可繼續寫入）、`error`（寫入失敗）。
   * 範例：Express 的 `res` 物件。

---
hideInToc: true
---
# Node.js 串流的四種類型

介於來源和目的之間的資料流，可以視為傳遞資料的管道


3. **複式串流（Duplex Stream）**

   * 同時具備可讀與可寫能力。
   * 用於雙向資料流動的場景，如網路通訊端（socket）。

4. **轉換串流（Transform Stream）**

   * 特殊的複式串流，能在資料流動時進行轉換處理。
   * 範例：壓縮、加密、解壓縮、解析。


---
hideInToc: true
---

**Pipe（導管）機制**

* 可將「可讀串流的輸出」直接連接到「可寫串流的輸入」。
* 節省記憶體、簡化資料傳輸過程。
* React 的串流式伺服器算繪（Streaming SSR）正是利用這種機制運作。

**背壓（Backpressure）機制**

* 當可寫串流處理速度追不上可讀串流的輸出時，資料會在緩衝區累積。
* 運作方式：
  * 可讀串流會暫停發出 `data` 事件，避免資料遺失。
  * 可寫串流處理完畢後會發出 `drain` 事件，通知可讀串流繼續輸出。
* 目的：確保資料傳輸穩定、記憶體使用高效，適用於大型資料或網路通訊場景。

---
hideInToc: true
---

**React 的 renderToPipeableStream**

- 在 React 中，`renderToPipeableStream()` 是伺服器端渲染（SSR）架構 Fizz 的一部分。
- 它的作用是把 React 元件以串流方式輸出到 Node.js 的可寫串流中，讓伺服器能在部分 HTML 準備好時就開始回傳，而不是等整份頁面產生完再送出。
- 這種做法能縮短使用者第一次看到畫面的時間（TTFB），提升效能。

<br/>
<div class="flex justify-center h-60">
  <img border="rounded" src="https://cover.sli.dev" alt="" style="max-width: 600px; width: 80%;">
</div>

---
hideInToc: true
---

**1. 建立請求（Create Request）**

React 先建立一個 **請求物件**，裡面包含：

* 要渲染的 React 元素
* 資源與狀態資訊
* 回應與格式設定


**2. 啟動渲染（Start Work）**

呼叫 `startWork()` 啟動非同步渲染程序。

* 若遇到 **Suspense**，會暫停該部分直到資料載入完成。
* 可以先輸出「載入中」畫面，再漸進補上完整內容。

🧠 Suspense 讓伺服器算繪能「漸進式」輸出。

---
hideInToc: true
---

**3. 回傳控制器（Return Stream Controller）**

`renderToPipeableStream()` 回傳一個物件，包含：

* **`pipe()`** → 把渲染結果輸出到可寫串流（如 `res`）
* **`abort()`** → 中止算繪、交由前端接手

**4. 串流輸出（Pipe to Destination）**

呼叫 `pipe()` 後：

* React 開始把 HTML 一塊塊寫入回應串流
* 監聽 `drain`、`error`、`close` 事件，控制資料流動狀態

**5. 錯誤與中止（Abort Rendering）**

* 若串流錯誤或被中斷 → 執行 `abort()`
* 停止伺服器端渲染、切換到用戶端復原模式

---
hideInToc: true
layout: image-right
image: https://cover.sli.dev
---

`renderToPipeableStream` 是 React 伺服器算繪架構 **Fizz** 的核心。

它讓頁面能夠：

* 提前輸出 HTML、加快回應速度
* 搭配 Suspense 進行漸進式渲染
* 提升整體效能與使用者體驗

---
hideInToc: true
---

# renderToPipeableStream 的優點

---
hideInToc: true
---

# 適用情境

---
hideInToc: true
---


---
hideInToc: true
---



# renderToReadableStream

---
hideInToc: true
---

# 何時該使用哪一種？
