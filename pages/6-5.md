# 於 React 中的伺服器渲染 API

<br />

我們在 Express 中透過 Server Side Render 的方式建立 React App。

其中最主要的是我們使用了 `ReactDOMServer.renderToString()`，將 React APP 渲染成 HTML 字串。

接下來會討論幾個 React 提供的 SSR API，包含用法、優點、缺點以及何時適合將其運用：

- `renderToString()`
- `renderToPipableStream()`
- `renderToReadableStream()`

---
hideInToc: true
---

# renderToString

將 react 組件渲染成完整的 html 字串

優點: 因為 api 是同步的，因此可以回傳一個完整的 HTML 字串，有助於提升效能、SEO和便利性。

用法: 從 `react-dom/server` 套件匯入 `renderToString()`

```jsx
import React from "react"
import { renderToString } from "react-dom/server"

function App(){
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>This is a simple React app.</p>
    </div>
  )
}

const html = renderToString(<App/>)
console.log(html)
```

---
hideInToc: true
---


## 它是如何運作的

`renderToString()` 會遍歷 react 元素 tree，輸出字串來轉換成真實 DOM 元素


```jsx
// React JSX
React.createElement("div", {}, 'hello world!')

// output
{ 
  type: "div", 
  props: {},
  children: ['hello world!'] 
}

// next for renderToString API
// ...
```


### JSX 轉換成 HTML 的流程

`JSX` -> `React.createElement` -> `React element` -> `renderToString(React element)` -> `HTML` 

`renderToString()` 的輸出讓我們更容易理解 React 如何用宣告式語法構建出實際的 DOM 樹狀結構。

---
hideInToc: true
---

### 問題：如果一次大量要處理複雜的 react element tree?

```jsx
React.createElement( 
  "section",
  { id: "list" }, 
  React.createElement("h1", {}, "This is my list!"),
  React.createElement("p", {}, "Isn't my list amazing? It contains amazing things!"),
  React.createElement("ul", {}, 
    amazingThings.map((t) => React.createElement("li", { key: t.id }, t.label))
  )
);
```
     
轉換成這段程式： 

```html
<section id="list"> 
  <h1>This is my list!</h1> 
  <p>Isn't my list amazing? It contains amazing things!</p> 
  <ul> 
    <li>Thing 1</li> 
    <li>Thing 2</li> 
    <li>Thing 3</li>
  </ul>
</section>
```

---
hideInToc: true
---

### 缺點

`renderToString()` 採用同步運行，必須先生成整個 HTML 字串才能回傳。

這會帶來幾個問題:
- 效能瓶頸：大型應用在生成整頁內容時，可能造成事件迴圈被阻塞、記憶體暴增，導致伺服器回應變慢或崩潰。
- 無法串流：因為必須等整個 HTML 完成後才能輸出，會造成較長的 TTFB（Time To First Byte），使用者需更久才能看到畫面。

為了改善這些限制，React 提供了可串流輸出的替代 API，如:
- `renderToPipeableStream`（Node.js）
- `renderToReadableStream`（瀏覽器）

目標：**能邊生成邊傳送 HTML，提升效能與回應速度** 。

---
hideInToc: true
---

# renderToPipeableStream
1. 適用於大型的 React App 渲染至 node.js
2. 完全支援 React 並行功能（包括 Suspense），可以在伺服器炫渲染期間更妥善的處理非同步資料提取。
3. 以非同步和累加的方式將 HTML 區塊送到用戶端，帶來更快的 TTFB 值。

<br/>

### 寫法參考：[Github](https://github.com/Yo0GuitarIT/react-ssr-demo)
切換 branch: `renderToPipeableStream`


<div style="width: 100%; display: flex; justify-content: end; margin-top: -80px">
  <img 
    src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*il9OcmDsPM3v5JP05fpYFA.png" 
    alt="" 
    style="width: auto; height: 280px;"/>
</div>

---
hideInToc: true
---

# renderToReadableStream

---
hideInToc: true
---

# 何時該使用哪一種？
