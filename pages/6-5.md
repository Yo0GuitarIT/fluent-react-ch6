# 於 React 中的伺服器渲染 API

<br />

我們在 Express 中透過 Server Side Render 的方式建立 React App。

其中最主要的是我們使用了 `ReactDOMServer.renderToString()`，將 React APP 渲染成 HTML 字串。

接下來會討論幾個 React 提供的 SSR API，包含用法、優點、缺點以及何時適合將其運用：

- `renderToString()`
- `renderToPipableStream()`
- `renderToReadableStream()`

---
hideInToc: true
---

# renderToString

將 react 組件渲染成完整的 html 字串

優點: 因為 api 是同步的，因此可以回傳一個完整的 HTML 字串，有助於提升效能、SEO和便利性。

用法: 從 `react-dom/server` 套件匯入 `renderToString()`

```jsx
import React from "react"
import { renderToString } from "react-dom/server"

function App(){
  return (
    <div>
      <h1>Hello, World!</h1>
      <p>This is a simple React app.</p>
    </div>
  )
}

const html = renderToString(<App/>)
console.log(html)
```

---
hideInToc: true
---


## 它是如何運作的

`renderToString()` 會遍歷 react 元素 tree，輸出字串來轉換成真實 DOM 元素


```jsx
// React JSX
React.createElement("div", {}, 'hello world!')

// output
{ 
  type: "div", 
  props: {},
  children: ['hello world!'] 
}

// next for renderToString API
// ...
```


### JSX 轉換成 HTML 的流程

`JSX` -> `React.createElement` -> `React element` -> `renderToString(React element)` -> `HTML` 

`renderToString()` 的輸出讓我們更容易理解 React 如何用宣告式語法構建出實際的 DOM 樹狀結構。

---
hideInToc: true
---

### 問題：如果一次大量要處理複雜的 react element tree?

```jsx
React.createElement( 
  "section",
  { id: "list" }, 
  React.createElement("h1", {}, "This is my list!"),
  React.createElement("p", {}, "Isn't my list amazing? It contains amazing things!"),
  React.createElement("ul", {}, 
    amazingThings.map((t) => React.createElement("li", { key: t.id }, t.label))
  )
);
```
     
轉換成這段程式： 

```html
<section id="list"> 
  <h1>This is my list!</h1> 
  <p>Isn't my list amazing? It contains amazing things!</p> 
  <ul> 
    <li>Thing 1</li> 
    <li>Thing 2</li> 
    <li>Thing 3</li>
  </ul>
</section>
```

---
hideInToc: true
---

### 缺點

`renderToString()` 採用同步運行，必須先生成整個 HTML 字串才能回傳。

這會帶來幾個問題:
- 效能瓶頸：大型應用在生成整頁內容時，可能造成事件迴圈被阻塞、記憶體暴增，導致伺服器回應變慢或崩潰。
- 無法串流：因為必須等整個 HTML 完成後才能輸出，會造成較長的 TTFB（Time To First Byte），使用者需更久才能看到畫面。

為了改善這些限制，React 提供了可串流輸出的替代 API，如:
- `renderToPipeableStream`（Node.js）
- `renderToReadableStream`（瀏覽器）

目標：**能邊生成邊傳送 HTML，提升效能與回應速度** 。

---
hideInToc: true
---

# renderToPipeableStream
1. 適用於大型的 React App 渲染至 node.js
2. 完全支援 React 並行功能（包括 Suspense），可以在伺服器炫渲染期間更妥善的處理非同步資料提取。
3. 以非同步和累加的方式將 HTML 區塊送到用戶端，帶來更快的 TTFB 值。

<br/>

### 寫法參考：[Github](https://github.com/Yo0GuitarIT/react-ssr-demo)
切換 branch: `renderToPipeableStream`


<div style="width: 100%; display: flex; justify-content: end; margin-top: -80px">
  <img 
    src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*il9OcmDsPM3v5JP05fpYFA.png" 
    alt="" 
    style="width: auto; height: 280px;"/>
</div>

---
hideInToc: true
---

# 運作方式
1. 接收 React element 轉換成 node.js 串流（~~HTML字串~~） 
2. 以區塊（chunk）方式處理處理資料，使用於大型 React App

<br />
<div class="flex justify-center">
  <img border="rounded" src="https://cover.sli.dev" alt="" style="max-width: 600px; width: 80%;">
</div>


---
hideInToc: true
---

# Node.js 串流的四種類型
介於來源和目的之間的資料流，可以視為傳遞資料的管道

1. **可讀串流（Readable Stream）**

   * 代表資料來源，可被讀取。
   * 會觸發事件：`data`、`end`、`error`。
   * 範例：讀檔案、接收 HTTP 請求、產生器產生資料。
   * React 的 `renderToPipeableStream()` 回傳的就是可讀串流，可將 HTML 輸出到可寫串流（如 `res`）。

2. **可寫串流（Writable Stream）**

   * 代表資料的目的地，可被寫入。
   * 主要方法：`write()`、`end()`。
   * 事件：`drain`（可繼續寫入）、`error`（寫入失敗）。
   * 範例：Express 的 `res` 物件。

---
hideInToc: true
---
# Node.js 串流的四種類型

介於來源和目的之間的資料流，可以視為傳遞資料的管道


3. **複式串流（Duplex Stream）**

   * 同時具備可讀與可寫能力。
   * 用於雙向資料流動的場景，如網路通訊端（socket）。

4. **轉換串流（Transform Stream）**

   * 特殊的複式串流，能在資料流動時進行轉換處理。
   * 範例：壓縮、加密、解壓縮、解析。


---
hideInToc: true
---

**Pipe（導管）機制**

* 可將「可讀串流的輸出」直接連接到「可寫串流的輸入」。
* 節省記憶體、簡化資料傳輸過程。
* React 的串流式伺服器算繪（Streaming SSR）正是利用這種機制運作。

**背壓（Backpressure）機制**

* 當可寫串流處理速度追不上可讀串流的輸出時，資料會在緩衝區累積。
* 運作方式：
  * 可讀串流會暫停發出 `data` 事件，避免資料遺失。
  * 可寫串流處理完畢後會發出 `drain` 事件，通知可讀串流繼續輸出。
* 目的：確保資料傳輸穩定、記憶體使用高效，適用於大型資料或網路通訊場景。

---
hideInToc: true
---

# React 的 renderToPipeableStream

- 在 React 中，`renderToPipeableStream()` 是伺服器端渲染（SSR）架構 Fizz 的一部分。
- 它的作用是把 React 元件以串流方式輸出到 Node.js 的可寫串流中，讓伺服器能在部分 HTML 準備好時就開始回傳，而不是等整份頁面產生完再送出。
- 這種做法能縮短使用者第一次看到畫面的時間（TTFB），提升效能。

<br/>
<div class="flex justify-center h-60">
  <img border="rounded" src="https://cover.sli.dev" alt="" style="max-width: 600px; width: 80%;">
</div>

---
hideInToc: true
---

**1. 建立請求（Create Request）**

React 先建立一個 **請求物件**，裡面包含：

* 要渲染的 React 元素
* 資源與狀態資訊
* 回應與格式設定


**2. 啟動渲染（Start Work）**

呼叫 `startWork()` 啟動非同步渲染程序。

* 若遇到 **Suspense**，會暫停該部分直到資料載入完成。
* 可以先輸出「載入中」畫面，再漸進補上完整內容。

🧠 Suspense 讓伺服器算繪能「漸進式」輸出。

---
hideInToc: true
---

**3. 回傳控制器（Return Stream Controller）**

`renderToPipeableStream()` 回傳一個物件，包含：

* **`pipe()`** → 把渲染結果輸出到可寫串流（如 `res`）
* **`abort()`** → 中止算繪、交由前端接手

**4. 串流輸出（Pipe to Destination）**

呼叫 `pipe()` 後：

* React 開始把 HTML 一塊塊寫入回應串流
* 監聽 `drain`、`error`、`close` 事件，控制資料流動狀態

**5. 錯誤與中止（Abort Rendering）**

* 若串流錯誤或被中斷 → 執行 `abort()`
* 停止伺服器端渲染、切換到用戶端復原模式

---
hideInToc: true
layout: image-right
image: https://cover.sli.dev
---

`renderToPipeableStream` 是 React 伺服器渲染架構 **Fizz** 的核心。

它讓頁面能夠：

* 提前輸出 HTML、加快回應速度
* 搭配 Suspense 進行漸進式渲染
* 提升整體效能與使用者體驗

---
hideInToc: true
---

# renderToPipeableStream 的特點

1. 使用串流：回傳可以 pipe 的 Node.js 串流，逐步傳遞渲染內容，提升效能和使用者體驗。

2. 靈活：可與其他 Node.js 串流平台整合，精準控制 HTML 渲染方式。

3. 支援 Suspense：該 API 完全支援 React 的並行功能，所以可以在伺服器渲染的時候，更有效的管理非同步資料提取和延遲載入，確保只有在有必要的資料可用時，才渲染該資料的組件。


---
hideInToc: true
---

# 適用情境

---
hideInToc: true
layout: two-cols
layoutClass: gap-16
---

## renderToReadableStream

React 使用網路串流 API 來實現 SSR 的方法。

::right::

```javascript
const readableStream = new ReadableStream({
  start(controller) {
    controller.enqueue('Hello, ');
    controller.enqueue('world!');
    controller.close();
  }
});

const reader = readableStream.getReader();

async function readAllChunks(streamReader) {
  let result = "";
  while (true) {
    const { done, value } = await streamReader.read();
    if (done) {
      break;
    }
    result += value;
  }
  return result;
}

readAllChunks(reader).then((text) => {
  console.log(text);
});
```



---
hideInToc: true
zoom: 0.8
---

| 項目 | Node.js 串流 | 瀏覽器串流 |
|------|---------------|-------------|
| 設計環境 | 伺服器端（Server-side） | 用戶端（Client-side） |
| 主要用途 | 檔案 I/O、網路 I/O、伺服器端資料傳輸 | 處理網路請求、媒體串流、前端資料處理 |
| 標準依據 | Node.js 自訂 API | WHATWG Streams 標準 |
| API 風格 | 基於事件（event-driven） | 基於 Promise 的現代 API |
| 主要事件/方法 | `data`、`end`、`error`、`pipe()` | `read()`、`write()`、`pipeThrough()` |
| 串流類型 | 可讀（Readable）、可寫（Writable）、雙工（Duplex）、轉換（Transform） | 可讀（ReadableStream）、可寫（WritableStream）、可轉換（TransformStream） |
| 典型使用情境 | 處理大型檔案上傳、串流回應、伺服器端資料轉換 | Fetch API 回應串流、影片播放、即時資料更新 |
| 資料流控制 | 使用背壓（Backpressure）機制控制事件觸發 | 透過內建的背壓控制與 Promise 鏈式處理 |
| 相容性 | Node.js 環境限定 | 現代瀏覽器（支援 WHATWG Streams 的環境） |


---
hideInToc: true
zoom: 0.85
---

# 何時該使用哪一種？

1. **`renderToString` 是同步的**：會一次性算出整個 HTML 字串並回傳，無法等待任何非同步資料完成。
2. **同步造成兩個主要問題**：
   * **無法等待非同步 I/O**（資料庫、網路、檔案等），導致回傳給瀏覽器的是未填滿資料的 shell，會造成 client 在 hydration 後補資料、產生 network waterfall。
   * **阻塞伺服器資源**：單一請求同步算圖會佔用執行緒/事件迴圈資源，對多用戶場景不友善（其他請求被延遲）。
3. **Streaming API（`renderToPipeableStream` / `renderToReadableStream`）的優點**：基於非同步流，能邊產生邊送出，減少阻塞、可以先發送 shell 再逐漸填入資料，改善延遲與資源利用。
4. **環境差異**：`renderToPipeableStream` 偏向伺服器端（Node 的流式 API），`renderToReadableStream` 偏向瀏覽器原生（WHATWG Streams）；選擇要看執行環境。
5. **現實限制**：許多第三方庫（特別是資料抓取或 CSS-in-JS）目前還沒完整支援 streaming 的使用者故事，導致實作複雜。
6. **實用條件**：除非你能在呼叫 streaming 前**事先取得所有必要資料**（或用 SSR 完整預先 render 收集 CSS 類別），否則 streaming 的好處可能會被抵銷。
7. **結論**：沒有一體適用的答案 —— 要依專案需求、第三方相容性與團隊能否重新設計資料流程來決定；採用框架（由框架替你選）通常是最簡單、最安全的選擇。


---
hideInToc: true
zoom: 0.8
---

| 問題/場景 | 推薦使用 `renderToString` | 推薦使用 Streaming (`renderToPipeableStream` / `renderToReadableStream`) |
|---|---:|---:|
| 必須在伺服器端完全渲染並回傳完整 HTML（例如：SEO、完整 CSS 樣式） | ✅ | ❌（除非能事前抓齊資料或預渲染 CSS） |
| 資料大量且需要非同步取得（DB、外部 API） | ❌（同步會阻塞、無法等待） | ✅（可邊抓邊送，減少阻塞） |
| 高併發、多使用者同時請求 | ❌（會造成伺服器等待/阻塞） | ✅（非同步流能更好利用資源） |
| 使用大量不支援 streaming 的第三方庫（資料或 CSS） | ✅（較穩定） | ❌（可能無法正常運作） |
| 可以在回應前保證已取得所有必要資料或預先產生 CSS | ❌（同步設計不再有優勢） | ✅（能發揮效能與延遲優勢） |
| 想把決策交給成熟框架（讓框架處理相容性） | ✅（簡單、安全） | ✅（若框架已支援 streaming） |

